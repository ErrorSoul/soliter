-- cursor.script
go.property("selected_card", nil)

function init(self)
   -- Отключаем лишние сообщения о коллизиях
   self.is_processing = false
   self.valid = false
   -- Получаем размеры окна при старте
   self.tableau_stacks = {}
   self.last_cards = {}
   self.was_pressed = false
   self.size = vmath.vector3(90, 150, 0)
   self.half_size = self.size * 0.5
   msg.post(".", "acquire_input_focus")
   -- Draw colored text on the screen
end


function on_input(self, action_id, action)
   self.cursor_pos = vmath.vector3(action.x, action.y, 0)
   go.set_position(self.cursor_pos, ".")


   if action_id == hash("space") then

      if action.pressed then
         msg.post("@system:", "toggle_physics_debug") -- <3>
      else
         msg.post("@system:", "toggle_physics_debug") -- <3>
      end
   end
   if action_id == hash("touch") then
      if action.pressed then
         self.was_pressed = true

         local card = check_tableau_slots(self, action.x, action.y)
         pprint(card)
         if card then
            self.selected_card = card.id
            self.selected_card_data = card.source
            self.is_dragging = true
            self.original_position = card.pos
            msg.post(self.selected_card, "start_drag")
            return
         end
         local free_slot = check_free_slots(self, action.x, action.y)

         if free_slot then
            self.pending_drop = free_slot
            msg.post(free_slot.slot_id, "can_pick_card")
            return
         end

      elseif action.released then
         self.was_pressed = false
         if self.is_dragging and self.selected_card then

            local flower_slot = check_flower_slot(self, action.x, action.y)
            if flower_slot then
               self.pending_drop = {slot = flower_slot}
               msg.post(flower_slot.slot_id, "check_slot", {card = self.selected_card_data})
               return
            end

            local free_slot = check_free_slots(self, action.x, action.y)
            if free_slot then
               self.pending_drop = {slot = free_slot}
               msg.post(free_slot.slot_id, 'check_slot')
               return
            end

            local card = check_last_cards(self, action.x, action.y)

            if card then
               self.pending_drop = {card = card, slot_id = card.slot_id}
               msg.post(card.id, "can_move_card", {card = self.selected_card_data})
               return
            end

            local base_slot = check_base_slots(self, action.x, action.y)
            if base_slot then
               self.pending_drop = {slot = base_slot}
               msg.post(base_slot.slot_id, 'check_slot', {card = self.selected_card_data})
               return
            end

            local tableau_slot = check_free_tableau_slots(self, action.x, action.y)
            if tableau_slot then
               self.pending_drop = {slot = tableau_slot}
               msg.post(tableau_slot.slot_id, 'check_slot', {card = self.selected_card_data})
               return
            end

            msg.post(self.selected_card, 'drop_failed', {position = self.original_position})
            clean_cursor(self)
         end
      end




      if self.is_dragging and self.selected_card then
         msg.post(self.selected_card, "drag_update", {position = self.cursor_pos})
      end
   end
end

function on_message(self, message_id, message, sender)
   print("[CURSOR]", message_id)
   if message_id == hash("set_free_slots") then
      self.free_slots = message

   elseif message_id == hash("set_flower_slot") then
      self.flower_slot = message
      pprint(self.flower_slot)
   elseif message_id == hash("set_base_slots") then
      self.base_slots = message
   elseif message_id == hash("set_tableau_slots") then
      self.tableau_slots = message
   elseif message_id == hash("set_cards") then
      self.cards = message
   elseif message_id == hash("set_stack") then
      self.tableau_stacks[message.index] = message.stack
      if #message.stack == 0 then
         self.tableau_slots['tableau_slot'..message.index].is_empty = true
         pprint("SELF TABLEAU SLOTS", self.tableau_slots)
      end

   elseif message_id == hash("set_last_cards") then
      self.last_cards[message.index] = message.card
   elseif message_id == hash("slot_valid") and self.pending_drop then
      msg.post(self.selected_card, 'drop_success', {
                  slot_id = self.pending_drop.slot.slot_id,
                  position = self.pending_drop.slot.slot_pos,
                  card = self.selected_card_data

      })
      clean_cursor(self)
   elseif message_id == hash("slot_invalid") and self.pending_drop then
      msg.post(self.selected_card, 'drop_failed', {position = self.original_position})
      clean_cursor(self)
   elseif message_id == hash("invalid_card")  then
      msg.post(self.selected_card, 'drop_failed', {position = self.original_position})
      clean_cursor(self)
   elseif message_id == hash("valid_card") and self.pending_drop then
      msg.post(self.selected_card, 'drop_success', {
                  position = (self.pending_drop.card.pos + vmath.vector3(0, -40, 0)),
                  slot_id = self.pending_drop.slot_id,
                  card = self.selected_card_data
      })
      clean_cursor(self)
   elseif message_id == hash("slot_with_card") and self.pending_drop then
      self.selected_card = message.id
      self.selected_card_data = message
      self.is_dragging = true
      self.original_position = self.pending_drop.slot_pos
      msg.post(self.selected_card, "start_drag")
   end
end

function clean_cursor(self)
   self.selected_card = nil
   self.selected_card_data = nil
   self.is_dragging = false
   self.current_slot = nil
   self.pending_drop = nil
end

local function is_point_in_rect(x, y, rect_pos, half_size)
   return (x > rect_pos.x - half_size.x and
           x < rect_pos.x + half_size.x and
           y > rect_pos.y - half_size.y and
           y < rect_pos.y + half_size.y)
end

function check_tableau_slots(self, cursor_x, cursor_y)
   -- Проверяем каждую стопку
   for stack_index, stack in ipairs(self.tableau_stacks) do

      -- Если курсор над стопкой, проверяем каждую карту в стопке
      for card_index = #stack, 1, -1 do
         local card = stack[card_index]
         local card_pos = go.get_position(card.id)


         -- Проверяем, находится ли курсор над картой
         if is_point_in_rect(cursor_x, cursor_y, card_pos, self.half_size) then
            return {
               type = "tableau",
               id  = card.id,
               stack_index = stack_index,
               card_index = card_index,
               card_data = card.data,
               data_id = card.data.id,
               pos = card_pos,
               slot_id = card.slot_id,
               source = card
            }
         end
      end
   end
   -- Если курсор не над стопкой, возвращаем nil
   return nil
end


function check_last_cards(self, cursor_x, cursor_y)

   -- Если курсор над стопкой, проверяем каждую карту в стопке
   for stack_index, card in ipairs(self.last_cards) do
        local card_pos = go.get_position(card.id)
        pprint('cARRRRR',card.id)

      -- Проверяем, находится ли курсор над картой
      if card.id ~= self.selected_card and is_point_in_rect(cursor_x, cursor_y, card_pos, self.half_size) then
         pprint("Cardddd", card)
         return {
            type = "tableau",
            id  = card.id,
            stack_index = stack_index,
            card_index = card_index,
            card_data = card.data,
            data_id = card.data.id,
            slot_id = card.slot_id,
            pos = card_pos,
            source = card
         }
      end
   end
   -- Если курсор не над стопкой, возвращаем nil
   return nil
end

function check_free_slots(self, cursor_x, cursor_y)
   for slot_id, slot_pos in pairs(self.free_slots) do
      if is_point_in_rect(cursor_x, cursor_y, slot_pos, self.half_size) then
         return {slot_id = slot_id, slot_pos = slot_pos}
      end
   end
end

function check_flower_slot(self, cursor_x, cursor_y)
   local slot_id = 'flower_slot'
   if is_point_in_rect(cursor_x, cursor_y, self.flower_slot[slot_id], self.half_size) then
      return {slot_id = slot_id, slot_pos = self.flower_slot[slot_id]}
   end
end

function check_base_slots(self, cursor_x, cursor_y)
   for slot_id, slot_pos in pairs(self.base_slots) do
      print("Base slot pos", slot_id)
      if is_point_in_rect(cursor_x, cursor_y, slot_pos, self.half_size) then
         return {slot_id = slot_id, slot_pos = slot_pos}
      end
   end
end

function check_free_tableau_slots(self, cursor_x, cursor_y)
   for slot_id, slot in pairs(self.tableau_slots) do

      if slot.is_empty and is_point_in_rect(cursor_x, cursor_y, slot.pos, self.half_size) then
         pprint("tableau slot pos", slot_id)
         return {slot_id = slot_id, slot_pos = slot.pos}
      end
   end
end



function update(self, dt)
   -- Преобразуем все объекты в строки и объединяем их
   local debug_string = "selected_card: " .. tostring(self.selected_card_data and self.selected_card_data.data_id or nil) .. "\n" ..
      "is_dragging: " .. tostring(self.is_dragging) .. "\n" ..
      "current_slot: " .. tostring(self.current_slot) .. "\n" ..
      "can_drop: " .. tostring(self.can_drop) .. "\n" ..
      "potential_card: " .. tostring(self.potential_card) .. "\n"..
      "message: " .. tostring(self.mes) .. "\n" ..
      "overlapped_card: " .. tostring(self.overlapped_card) .. "\n"

   local color_green = vmath.vector4(0, 1, 0, 1)
   msg.post("@render:", "draw_debug_text", { text = debug_string, position = vmath.vector3(800, 780, 0), color = color_green })
end
